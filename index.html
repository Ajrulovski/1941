<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>1941: Battle of Midway - High Score Edition</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            touch-action: none; 
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* HUD */
        #top-bar {
            position: absolute; top: 10px; width: 100%;
            display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box;
        }
        #score-box { color: #FFFF00; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000; }
        #health-container { width: 200px; height: 20px; border: 2px solid white; background: #333; }
        #health-fill { width: 100%; height: 100%; background-color: #00ff00; transition: width 0.2s; }

        /* Boss HUD */
        #boss-hud {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            width: 400px; display: none; text-align: center;
        }
        #boss-label { color: #ff0000; font-weight: bold; font-size: 20px; text-shadow: 1px 1px 0 #000; margin-bottom: 5px; }
        #boss-health-container { width: 100%; height: 20px; border: 2px solid #ff0000; background: #330000; }
        #boss-health-fill { width: 100%; height: 100%; background-color: #ff0000; transition: width 0.1s; }

        /* Screens */
        #level-msg {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; font-size: 40px; font-weight: bold; text-shadow: 0 0 10px #00ffff;
            text-align: center; opacity: 0; transition: opacity 0.5s;
        }
        #game-over, #pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; flex-direction: column; 
            justify-content: center; align-items: center; color: white; pointer-events: auto;
        }
        
        button.action-btn {
            background: #f00; color: white; border: 2px solid white;
            padding: 10px 30px; font-size: 20px; cursor: pointer; margin-top: 20px;
            font-family: 'Courier New', Courier, monospace; font-weight: bold;
        }
        button.action-btn:hover { background: #ff4444; }

        #pause-btn {
            pointer-events: auto; background: #444; color: white; border: 2px solid white;
            padding: 5px 15px; font-weight: bold; cursor: pointer;
        }

        /* HIGH SCORE STYLES */
        #highscore-container {
            margin-top: 20px;
            text-align: center;
            width: 300px;
        }
        #highscore-list {
            list-style: none; padding: 0; margin: 10px 0;
            border: 1px solid #555; background: rgba(0,0,0,0.5);
        }
        #highscore-list li {
            padding: 5px; border-bottom: 1px solid #333;
            display: flex; justify-content: space-between;
            color: #FFFF00; font-size: 18px;
        }
        #highscore-list li:last-child { border-bottom: none; }
        
        #input-form { display: none; margin-top: 15px; }
        #player-name {
            background: black; color: white; border: 2px solid #00ffff;
            font-size: 24px; width: 100px; text-align: center;
            font-family: 'Courier New', Courier, monospace;
            text-transform: uppercase;
        }
        .blinking { animation: blink 1s infinite; color: #00ffff; }
        @keyframes blink { 50% { opacity: 0; } }

        /* CONTROLS */
        #controls-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%; z-index: 5;
        }
        
        #joystick-wrapper {
            position: absolute; bottom: 30px; left: 30px;
            width: 140px; height: 140px;
            display: none; pointer-events: auto;
        }
        #joystick-base {
            width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%; position: relative;
        }
        #joystick-knob {
            width: 60px; height: 60px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%; position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            pointer-events: none; box-shadow: 0 0 10px rgba(0,255,255,0.5);
        }

        #fire-zone {
            position: absolute; bottom: 0; right: 0;
            width: 40%; height: 100%; pointer-events: auto;
        }

        .hint {
            position: absolute; bottom: 10px; width: 100%;
            text-align: center; color: rgba(255,255,255,0.5);
            pointer-events: none; font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="top-bar">
            <button id="pause-btn">PAUSE</button>
            <div id="score-box">SCORE: <span id="score">0</span></div>
            <div id="health-container"><div id="health-fill"></div></div>
        </div>
        
        <div id="boss-hud">
            <div id="boss-label">⚠ BOSS INCOMING ⚠</div>
            <div id="boss-health-container"><div id="boss-health-fill"></div></div>
        </div>

        <div id="level-msg">LEVEL 1<br>ENGAGE!</div>

        <div id="pause-overlay">
            <h1>PAUSED</h1>
            <button class="action-btn" id="resume-btn">RESUME</button>
        </div>

        <div id="game-over">
            <h1 id="end-title">MISSION FAILED</h1>
            <p>FINAL SCORE: <span id="final-score">0</span></p>
            
            <div id="highscore-container">
                <h3>TOP ACES</h3>
                <ul id="highscore-list">
                    </ul>
                
                <div id="input-form">
                    <p class="blinking">NEW HIGH SCORE!</p>
                    <input type="text" id="player-name" maxlength="3" placeholder="AAA">
                    <br>
                    <button class="action-btn" id="save-btn" style="padding: 5px 15px; font-size: 16px;">SAVE</button>
                </div>
            </div>

            <button class="action-btn" id="restart-btn" onclick="location.reload()">RESTART</button>
        </div>
    </div>
    
    <div id="controls-layer">
        <div id="joystick-wrapper">
            <div id="joystick-base">
                <div id="joystick-knob"></div>
            </div>
        </div>
        <div id="fire-zone"></div>
        <div class="hint" id="desktop-hint">ARROWS to Move | SPACE to Fire</div>
        <div class="hint" id="mobile-hint" style="display:none">Left Stick to Fly | Tap Right to Fire</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- CONFIG ---
        const VIEW_SIZE = 40; 
        const SCROLL_SPEED = 0.008; 
        const PLAYER_SPEED = 0.7;   
        const BULLET_SPEED = 1.2;
        const SPAWN_RATE = 0.015;     
        const ENEMY_FIRE_RATE = 0.003; 
        const POWERUP_DROP_RATE = 0.40;
        const BOSS_TRIGGER_SCORE = 3000;
        const MAX_HIGHSCORES = 5;

        // --- STATE ---
        let scene, camera, renderer;
        let player, groundMesh;
        let enemies = [];
        let playerBullets = [];
        let enemyBullets = [];
        let powerups = [];
        let particles = [];
        let boss = null;
        let highScores = [];
        
        let state = {
            score: 0,
            health: 100,
            level: 1,
            weaponLevel: 1,
            paused: false,
            gameOver: false,
            bossActive: false,
            difficulty: 1.0
        };

        const input = { x: 0, y: 0, firing: false };

        window.onload = function() {
            loadHighScores();
            init();
            animate();
        };

        // --- HIGHSCORE SYSTEM ---

        function loadHighScores() {
            const stored = localStorage.getItem('midway_highscores');
            highScores = stored ? JSON.parse(stored) : [
                {name: 'ACE', score: 5000},
                {name: 'USA', score: 3000},
                {name: 'BOB', score: 2000},
                {name: 'SKY', score: 1000},
                {name: 'JET', score: 500}
            ];
        }

        function checkHighScore() {
            const finalScore = Math.floor(state.score);
            const lowest = highScores[highScores.length - 1].score;
            
            renderHighScores(); // Show current list
            
            if (finalScore > lowest) {
                // Show Input
                document.getElementById('input-form').style.display = 'block';
                document.getElementById('restart-btn').style.display = 'none'; // Hide restart until saved
                document.getElementById('player-name').focus();
            } else {
                document.getElementById('input-form').style.display = 'none';
                document.getElementById('restart-btn').style.display = 'inline-block';
            }
        }

        function saveHighScore() {
            const nameInput = document.getElementById('player-name');
            let name = nameInput.value.toUpperCase();
            if (name.length === 0) name = "UNK";
            
            const newEntry = { name: name, score: Math.floor(state.score) };
            highScores.push(newEntry);
            
            // Sort Descending
            highScores.sort((a, b) => b.score - a.score);
            
            // Keep Top 5
            highScores = highScores.slice(0, MAX_HIGHSCORES);
            
            // Save
            localStorage.setItem('midway_highscores', JSON.stringify(highScores));
            
            // UI Update
            document.getElementById('input-form').style.display = 'none';
            document.getElementById('restart-btn').style.display = 'inline-block';
            renderHighScores();
        }

        function renderHighScores() {
            const list = document.getElementById('highscore-list');
            list.innerHTML = '';
            highScores.forEach(entry => {
                const li = document.createElement('li');
                li.innerHTML = `<span>${entry.name}</span> <span>${entry.score}</span>`;
                list.appendChild(li);
            });
        }

        document.getElementById('save-btn').addEventListener('click', saveHighScore);

        // --- INIT ---

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e3f5a); 

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                -VIEW_SIZE * aspect, VIEW_SIZE * aspect, 
                VIEW_SIZE, -VIEW_SIZE, 
                1, 1000
            );
            camera.position.set(0, 50, 0); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.9);
            sun.position.set(-20, 50, -20);
            sun.castShadow = true;
            sun.shadow.camera.left = -50; sun.shadow.camera.right = 50;
            sun.shadow.camera.top = 50; sun.shadow.camera.bottom = -50;
            scene.add(sun);

            createProceduralTerrain(1);
            player = createPlayerMesh();
            scene.add(player);

            setupControls();
            showLevelMessage(1);
            window.addEventListener('resize', onWindowResize);
        }

        // --- GAMEPLAY LOOP ---

        function animate() {
            requestAnimationFrame(animate);
            if (state.paused || state.gameOver) return;

            // Scroll Ground
            if (groundMesh) groundMesh.material.map.offset.y += SCROLL_SPEED * state.difficulty;

            // Player Logic
            player.position.x += input.x * PLAYER_SPEED;
            player.position.z += input.y * PLAYER_SPEED;
            player.position.x = Math.max(-28, Math.min(28, player.position.x));
            player.position.z = Math.max(-30, Math.min(30, player.position.z));
            player.rotation.z = -input.x * 0.4;
            player.children.forEach(c => { if(c.userData.spin) c.rotation.z += 1.0; });

            // Boss Check
            if (!state.bossActive && state.score >= BOSS_TRIGGER_SCORE && state.level === 1) {
                spawnBoss();
            }
            if (boss) updateBoss();

            // Spawn Enemies
            if (!state.bossActive && Math.random() < SPAWN_RATE * state.difficulty) {
                spawnEnemy();
            }

            // Update Enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                e.position.z += e.userData.speed + SCROLL_SPEED;
                
                if (Math.random() < ENEMY_FIRE_RATE * state.difficulty && e.position.z < 25) {
                    fireEnemy(e);
                }

                // 2D Collision with Player
                if (Math.abs(e.position.x - player.position.x) < 5 && Math.abs(e.position.z - player.position.z) < 5) {
                    takeDamage(15);
                    createExplosion(e.position);
                    scene.remove(e);
                    enemies.splice(i, 1);
                    continue;
                }

                if (e.position.z > 50) {
                    scene.remove(e);
                    enemies.splice(i, 1);
                }
            }

            // Powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                let p = powerups[i];
                p.position.z += 0.2;
                p.rotation.x += p.userData.rot.x;
                p.rotation.y += p.userData.rot.y;
                
                if (Math.abs(p.position.x - player.position.x) < 5 && Math.abs(p.position.z - player.position.z) < 5) {
                    state.weaponLevel = Math.min(3, state.weaponLevel + 1);
                    state.score += 500;
                    state.health = Math.min(100, state.health + 20);
                    updateHUD();
                    scene.remove(p);
                    powerups.splice(i, 1);
                } else if (p.position.z > 50) {
                    scene.remove(p);
                    powerups.splice(i, 1);
                }
            }

            // Player Bullets
            if (Date.now() % 150 < 20 && input.firing) firePlayer(); 

            for (let i = playerBullets.length - 1; i >= 0; i--) {
                let b = playerBullets[i];
                b.position.add(b.userData.vel);
                let hit = false;

                // Boss Hit
                if (boss && Math.abs(b.position.z - boss.position.z) < 6 && Math.abs(b.position.x - boss.position.x) < 14) {
                    boss.userData.hp -= 2;
                    updateBossUI();
                    createExplosion(b.position, 0.5);
                    if (boss.userData.hp <= 0) {
                        createExplosion(boss.position, 4);
                        scene.remove(boss);
                        boss = null;
                        document.getElementById('boss-hud').style.display = 'none';
                        state.score += 5000;
                        startLevel(2);
                    }
                    scene.remove(b);
                    playerBullets.splice(i, 1);
                    continue;
                }

                // Enemy Hit (2D)
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (Math.abs(b.position.x - e.position.x) < 5 && Math.abs(b.position.z - e.position.z) < 5) {
                        createExplosion(b.position);
                        e.userData.hp--;
                        if (e.userData.hp <= 0) {
                            createExplosion(e.position);
                            state.score += e.userData.score;
                            updateHUD();
                            if (Math.random() < POWERUP_DROP_RATE) spawnPowerUp(e.position);
                            scene.remove(e);
                            enemies.splice(j, 1);
                        }
                        scene.remove(b);
                        playerBullets.splice(i, 1);
                        hit = true;
                        break;
                    }
                }
                if (!hit && b.position.z < -60) {
                    scene.remove(b);
                    playerBullets.splice(i, 1);
                }
            }

            // Enemy Bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                let b = enemyBullets[i];
                b.position.add(b.userData.vel);
                if (b.position.distanceTo(player.position) < 3) { 
                    createExplosion(player.position);
                    takeDamage(10);
                    scene.remove(b);
                    enemyBullets.splice(i, 1);
                    continue;
                }
                if (b.position.z > 50 || b.position.z < -60) {
                    scene.remove(b);
                    enemyBullets.splice(i, 1);
                }
            }

            updateParticles();
            renderer.render(scene, camera);
        }

        // --- HELPERS ---

        function startLevel(lvl) {
            state.level = lvl;
            state.bossActive = false;
            if (lvl === 2) {
                state.difficulty = 1.2;
                createProceduralTerrain(2);
            }
            showLevelMessage(lvl);
        }

        function createProceduralTerrain(type) {
            if (groundMesh) { scene.remove(groundMesh); groundMesh.geometry.dispose(); }
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            if (type === 1) { // Ocean
                ctx.fillStyle = '#1e3f5a'; ctx.fillRect(0,0,512,1024);
                for(let i=0; i<15; i++) {
                    const x = Math.random()*512, y = Math.random()*1024, r = 30+Math.random()*30;
                    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle='#eecfa1'; ctx.fill();
                    ctx.beginPath(); ctx.arc(x,y,r*0.7,0,Math.PI*2); ctx.fillStyle='#4a8532'; ctx.fill();
                }
                scene.background = new THREE.Color(0x1e3f5a);
            } else { // Canyon
                ctx.fillStyle = '#8B4513'; ctx.fillRect(0,0,512,1024);
                ctx.strokeStyle = '#3e1e09'; ctx.lineWidth = 15;
                for(let i=0; i<8; i++) {
                    ctx.beginPath(); ctx.moveTo(Math.random()*512,0);
                    ctx.bezierCurveTo(Math.random()*512,300,Math.random()*512,600,Math.random()*512,1024);
                    ctx.stroke();
                }
                scene.background = new THREE.Color(0x8B4513);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(1,1);
            const geo = new THREE.PlaneGeometry(200, 200); geo.rotateX(-Math.PI/2);
            const mat = new THREE.MeshStandardMaterial({map:tex, roughness:0.9});
            groundMesh = new THREE.Mesh(geo, mat);
            groundMesh.position.y = -10; groundMesh.receiveShadow = true;
            scene.add(groundMesh);
        }

        function createPlayerMesh() {
            const mesh = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            mesh.add(new THREE.Mesh(new THREE.BoxGeometry(1, 1, 4), mat));
            mesh.add(new THREE.Mesh(new THREE.BoxGeometry(9, 0.2, 2), mat));
            const pMat = new THREE.MeshBasicMaterial({ color: 0x333 });
            const p1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2.5, 0.1), pMat);
            p1.position.set(-2, 0, -1.5); p1.userData={spin:true}; mesh.add(p1);
            const p2 = p1.clone(); p2.position.set(2, 0, -1.5); p2.userData={spin:true}; mesh.add(p2);
            mesh.position.y = 5; mesh.castShadow = true;
            return mesh;
        }

        function createEnemyPlane() {
            const mesh = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xaa3333 });
            const body = new THREE.Mesh(new THREE.ConeGeometry(1, 3, 4), mat);
            body.rotation.x = -Math.PI/2; body.rotation.y = Math.PI/4;
            mesh.add(body); mesh.add(new THREE.Mesh(new THREE.BoxGeometry(5, 0.1, 1), mat));
            mesh.userData = { hp: 2, type: 'plane', score: 100, speed: 0.25 };
            mesh.position.y = 5; mesh.castShadow = true; return mesh;
        }

        function createShip() {
            const mesh = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0x666 });
            mesh.add(new THREE.Mesh(new THREE.BoxGeometry(4, 2, 10), mat));
            const c = new THREE.Mesh(new THREE.CylinderGeometry(1,1,0.1), new THREE.MeshBasicMaterial({color:0xcc0000}));
            c.position.y = 1.1; mesh.add(c);
            mesh.userData = { hp: 5, type: 'ship', score: 300, speed: 0.05 };
            mesh.position.y = -5; mesh.castShadow = true; return mesh;
        }

        function createBossMesh() {
            const mesh = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0x550000 });
            mesh.add(new THREE.Mesh(new THREE.BoxGeometry(4, 3, 12), mat));
            mesh.add(new THREE.Mesh(new THREE.BoxGeometry(25, 1, 6), mat));
            mesh.userData = { hp: 150, maxHp: 150, type: 'boss', dir: 1, timer: 0 };
            mesh.castShadow = true; return mesh;
        }

        function firePlayer() {
            const createB = (ox, angle=0) => {
                const b = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 1.5), new THREE.MeshBasicMaterial({color:0xffff00}));
                b.position.copy(player.position); b.position.x+=ox; b.position.z-=2; b.rotation.y=angle;
                b.userData = { vel: new THREE.Vector3(Math.sin(angle)*1.2, 0, -Math.cos(angle)*1.2) };
                scene.add(b); playerBullets.push(b);
            };
            if(state.weaponLevel===1) createB(0);
            else if(state.weaponLevel===2) { createB(-1); createB(1); }
            else { createB(0); createB(-1.2, 0.15); createB(1.2, -0.15); }
        }

        function fireEnemy(obj) {
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:0xff0000}));
            b.position.copy(obj.position);
            const dir = new THREE.Vector3().subVectors(player.position, obj.position).normalize();
            b.userData = { vel: dir.multiplyScalar(0.4) };
            scene.add(b); enemyBullets.push(b);
        }

        function spawnEnemy() {
            const isShip = Math.random() > 0.6;
            let enemy = isShip ? createShip() : createEnemyPlane();
            enemy.position.z = -60;
            enemy.position.x = (Math.random() - 0.5) * 50;
            enemy.userData.speed *= state.difficulty;
            scene.add(enemy);
            enemies.push(enemy);
        }
        
        function spawnPowerUp(pos) {
            const geo = new THREE.BoxGeometry(2, 2, 2);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.add(new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({color: 0xffffff})));
            mesh.position.copy(pos); mesh.userData = { rot: new THREE.Vector3(0.05, 0.05, 0) };
            scene.add(mesh); powerups.push(mesh);
        }

        function spawnBoss() {
            state.bossActive = true;
            boss = createBossMesh();
            boss.position.set(0, 5, -60);
            scene.add(boss);
            document.getElementById('boss-hud').style.display = 'block';
            updateBossUI();
        }

        function updateBoss() {
            if(!boss) return;
            if(boss.position.z < -20) boss.position.z += 0.2;
            else {
                boss.position.x += 0.15 * boss.userData.dir * state.difficulty;
                if(boss.position.x > 20) boss.userData.dir = -1;
                if(boss.position.x < -20) boss.userData.dir = 1;
                boss.userData.timer++;
                if(boss.userData.timer > 60) {
                    fireEnemy(boss); fireEnemy(boss);
                    boss.userData.timer = 0;
                }
            }
        }

        function takeDamage(amt) {
            state.health -= amt;
            updateHUD();
            if(state.health <= 0) {
                state.health = 0;
                endGame(false);
            }
        }

        function endGame(win) {
            state.gameOver = true;
            document.getElementById('game-over').style.display = 'flex';
            document.getElementById('final-score').innerText = Math.floor(state.score);
            const title = document.getElementById('end-title');
            if (win) { title.innerText = "MISSION COMPLETE"; title.style.color = "#00ff00"; }
            else { title.innerText = "MISSION FAILED"; title.style.color = "#ff0000"; }
            checkHighScore();
        }

        function createExplosion(pos, scale=1) {
            for(let i=0; i<6; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.8*scale,0.8*scale,0.8*scale), new THREE.MeshBasicMaterial({color:0xffaa00}));
                p.position.copy(pos);
                p.userData={vel: new THREE.Vector3((Math.random()-0.5),0,(Math.random()-0.5)).multiplyScalar(0.5), life:20};
                scene.add(p); particles.push(p);
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.position.add(p.userData.vel); p.scale.multiplyScalar(0.9); p.userData.life--;
                if(p.userData.life<=0) { scene.remove(p); particles.splice(i,1); }
            }
        }

        function updateHUD() {
            document.getElementById('score').innerText = Math.floor(state.score);
            document.getElementById('health-fill').style.width = state.health + '%';
        }
        function updateBossUI() {
            if(boss) document.getElementById('boss-health-fill').style.width = (boss.userData.hp/boss.userData.maxHp)*100 + '%';
        }
        function showLevelMessage(lvl) {
            const msg = document.getElementById('level-msg');
            msg.innerHTML = `LEVEL ${lvl}<br>ENGAGE!`;
            msg.style.opacity = 1; setTimeout(() => msg.style.opacity = 0, 3000);
        }

        function setupControls() {
            window.addEventListener('keydown', e => {
                if(e.key==='ArrowLeft') input.x=-1; if(e.key==='ArrowRight') input.x=1;
                if(e.key==='ArrowUp') input.y=-1; if(e.key==='ArrowDown') input.y=1;
                if(e.code==='Space') input.firing=true;
                if(e.code==='KeyP') togglePause();
            });
            window.addEventListener('keyup', e => {
                if(['ArrowLeft','ArrowRight'].includes(e.key)) input.x=0;
                if(['ArrowUp','ArrowDown'].includes(e.key)) input.y=0;
                if(e.code==='Space') input.firing=false;
            });

            document.getElementById('pause-btn').addEventListener('click', togglePause);
            document.getElementById('resume-btn').addEventListener('click', togglePause);

            if ('ontouchstart' in window) {
                document.getElementById('desktop-hint').style.display = 'none';
                document.getElementById('mobile-hint').style.display = 'block';
                const wrapper = document.getElementById('joystick-wrapper');
                const knob = document.getElementById('joystick-knob');
                const fire = document.getElementById('fire-zone');
                
                wrapper.style.display = 'block';
                const maxDist = 40; 
                const handleJoy = (tx, ty, cx, cy) => {
                    let dx = tx-cx, dy = ty-cy, dist = Math.sqrt(dx*dx + dy*dy);
                    input.x = Math.max(-1, Math.min(1, dx/maxDist));
                    input.y = Math.max(-1, Math.min(1, dy/maxDist));
                    if(dist>maxDist) { dx*=maxDist/dist; dy*=maxDist/dist; }
                    knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                };

                wrapper.addEventListener('touchmove', e => {
                    e.preventDefault();
                    const t = e.touches[0], r = wrapper.getBoundingClientRect();
                    handleJoy(t.clientX, t.clientY, r.left+r.width/2, r.top+r.height/2);
                }, {passive:false});
                
                wrapper.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const t = e.touches[0], r = wrapper.getBoundingClientRect();
                    handleJoy(t.clientX, t.clientY, r.left+r.width/2, r.top+r.height/2);
                }, {passive:false});

                wrapper.addEventListener('touchend', e => {
                    e.preventDefault(); input.x=0; input.y=0; knob.style.transform=`translate(-50%, -50%)`;
                });
                fire.addEventListener('touchstart', e => { e.preventDefault(); input.firing=true; }, {passive:false});
                fire.addEventListener('touchend', () => input.firing=false);
            }
        }

        function togglePause() {
            if(state.gameOver) return;
            state.paused = !state.paused;
            document.getElementById('pause-overlay').style.display = state.paused ? 'flex' : 'none';
            if(!state.paused) animate();
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -VIEW_SIZE * aspect; camera.right = VIEW_SIZE * aspect;
            camera.top = VIEW_SIZE; camera.bottom = -VIEW_SIZE;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
